// base_offset_return-sh4-linux-gnu-gcc-9_text.c
// Generated by decompiling base_offset_return-sh4-linux-gnu-gcc-9
// using Reko decompiler version 0.9.1.0.

#include "base_offset_return-sh4-linux-gnu-gcc-9_text.h"

// 00000398: void deregister_tm_clones(Register word32 pr)
void deregister_tm_clones(word32 pr)
{
	int32 r12_9 = globals->dw03C0 + 0x03C0;
	if (globals->dw03C8 + r12_9 == globals->dw03C4 + r12_9)
		return;
	<anonymous> ** r1_18 = globals->ptr03CC + r12_9;
	if (r1_18 == null)
		return;
	(*r1_18)();
}

// 000003D0: void register_tm_clones(Register word32 pr)
void register_tm_clones(word32 pr)
{
	int32 r12_9 = globals->dw0408 + 0x0408;
	if ((globals->dw0410 + r12_9 - (globals->dw040C + r12_9) >> 2) + T >> 1 == 0x00)
		return;
	<anonymous> ** r1_28 = globals->ptr0414 + r12_9;
	if (r1_28 == null)
		return;
	(*r1_28)();
}

// 00000418: void __do_global_dtors_aux(Register word32 r8, Register word32 r9, Register word32 r11, Register word32 pr)
void __do_global_dtors_aux(word32 r8, word32 r9, word32 r11, word32 pr)
{
	int32 r10_20 = globals->dw0490;
	ptr32 r12_24 = globals->dw048C + 1164;
	if (!(r12_24 + r10_20 == 0x00))
		return;
	if (globals->dw0494 + r12_24 == 0x00)
	{
		struct Eq_101 * r11_37 = globals->dw04A8 + r12_24;
		int32 r1_31 = globals->dw04A0;
		Eq_108 r0_39 = r11_37->dw0000;
		Eq_108 r8_40 = (globals->dw04A4 - r1_31 >> 2) + ~0x00;
		int32 r9_42 = r1_31 + r12_24;
		if (r0_39 < r8_40)
		{
			uint32 r0_44 = (word32) r0_39.u1 + 1;
			while (true)
			{
				r11_37->dw0000 = r0_44;
				Eq_149 r0_48[] = r0_44 << 2;
				Eq_149 r1_50 = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&r0_48[r9_42].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
				word32 r4_65;
				(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&r1_50.a0000[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0]();
				Eq_108 r0_67 = r11_37->dw0000;
				if (r0_67 >= r8_40)
					break;
				r0_44 = (word32) r0_67.u1 + 1;
			}
		}
		int32 r0_72 = globals->dw04AC;
		int32 r10_84;
		ptr32 r12_86;
		word32 r4_89;
		(1144 + r0_72)();
		r12_86 + r10_84 = 0x01;
	}
	else
	{
		word32 r0_112 = globals->dw049C;
		int32 r1_111 = globals->dw0498;
		(0x0444 + r1_111)();
	}
}

// 000004B0: void frame_dummy()
void frame_dummy()
{
	int32 r1_4 = globals->dw04B8;
	(0x04B6 + r1_4)();
}

// 000004BC: void getIndex()
void getIndex()
{
}

// 000004C4: void foo(Register word32 r4, Register word32 r8, Register word32 pr)
void foo(word32 r4, word32 r8, word32 pr)
{
	if (r4 == 0x00)
		return;
	ui32 r0_16;
	word32 r8_17[];
	fn464C457E();
	r8_17[r0_16] = 0x00;
}

// 000004EC: void __do_global_ctors_aux(Register word32 pr)
void __do_global_ctors_aux(word32 pr)
{
	word32 r12_12 = globals->dw051C + 0x051C;
	struct Eq_190 * r8_16 = globals->dw0520 + r12_12;
	<anonymous> ** r0_19 = r8_16->ptrFFFFFFFC;
	if (r0_19 != (<anonymous> **) ~0x00)
	{
		word32 * r8_21 = &r8_16->ptrFFFFFFFC;
		do
		{
			(*r0_19)();
			r0_19 = *r8_21;
		} while (!(r0_19 == (<anonymous> **) ~0x00));
	}
}

